/*
 
This example illustrates a rewrite system that computes the gcd of two
integers.

Run the example with

./rmt -v 0 < 03-gcd-divisions-v2.rmt

The expected output is for the proof to go through.

The interesting part here is that we define the built-in function gcd
by repeated subtraction, but our rewrite system for computing the gcd
goes by repeated division. Unfortunately, Z3 cannot handle the SMT
queries that RMT produces (it timeouts or returns unknown), unless a
hint is provided as well (marked HINT) below.

Try to see what happens when you remove the hint.

Try to see what happens if you define the built-in function by
repeated division and the rewrite system by repeated subtraction. Do
you still need a hint? Does the same hint work? We have found that Z3
is weak for problem involving properties of "mod" and "-" and
consistently needs hints in order to solve them. We have also tried to
use CVC4, but unfortunately it cannot handle the non-linear equations
generated by this example.

*/
smt-prelude "
(declare-fun gcd (Int Int) Int)
(assert (forall ((x Int) (y Int))
(= (gcd x y)
     (ite (= y 0)
      x
      (gcd y (- x y))
     )
)))
(assert (forall ((X Int) (Y Int)) (= (gcd X Y) (gcd Y (mod X Y)))))" // HINT

sorts Int / "Int", Bool / "Bool", State;
// subsort Int < State;

signature mzero : -> Int / "0", mone : -> Int / "1", mtwo : -> Int / "2", mthree : -> Int / "3",
  mplus : Int Int->Int / "+", mminus : Int Int->Int / "-",
  mtimes : Int Int->Int / "*", mdiv : Int Int->Int / "div",
  mle : Int Int->Bool / "<=", mequals : Int Int->Bool / "=",
  mgcd : Int Int -> Int / "gcd", mg : Int Int -> Bool / ">",
  mmod : Int Int -> Int / "mod",

  bequals : Bool Bool->Bool / "=", band : Bool Bool->Bool / "and",
  bimplies : Bool Bool->Bool / "=>", bor : Bool Bool->Bool / "or",
  bnot : Bool->Bool / "not", true : ->Bool / "true", false : ->Bool / "false",

  init : Int Int -> State, loop : Int Int -> State, done : Int -> State,
  ok : Int Int -> State;

variables S : Int, N : Int, I : Int, J : Int, X : Int, Y : Int, Z : Int, A : Int, B : Int,
 C : Int, D : Int, BB : Bool;

rewrite-system simplifications
  bnot(false) => true, bnot(true) => false, bnot(bnot(BB)) => BB,
  band(false, BB) => false, band(true, BB) => BB, band(BB, false) => false,
  band(BB, true) => BB, bimplies(true, BB) => BB, bimplies(false, BB) => true,
  bor(false, BB) => BB, bor(true, BB) => true, bor(BB, false) => BB,
  bor(BB, true) => true, mequals(N, N) => true, bequals(BB, BB) => true,
  bequals(true, BB) => BB,bequals(false, BB) => bnot(BB), bequals(BB, true) => BB,
  bequals(BB, false) => bnot(BB), band(BB, BB) => BB, bor(BB, BB) => BB;

constrained-rewrite-system gcd
  init(X, Y) => loop(X, Y),

  loop(X, Y) /\ bnot(mequals(Y, mzero)) =>
  loop(Y, mmod(X, Y)),

  loop(X, Y) /\ mequals(Y, mzero) =>
  done(X);

constrained-rewrite-system circ
  init(X, Y) => done(mgcd(X, Y)),

  loop(X, Y) => done(mgcd(X, Y));

prove [5,2] in gcd : circ;
